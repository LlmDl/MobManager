/*
 * Copyright 2013 Michael McKnight. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and contributors and should not be interpreted as representing official policies,
 * either expressed or implied, of anybody else.
 */

package ninja.mcknight.bukkit.mobmanager.bounty.config.util;

import ninja.mcknight.bukkit.mobmanager.bounty.listeners.BountySpawnListener;
import ninja.mcknight.bukkit.mobmanager.common.util.ExtendedEntityType;
import ninja.mcknight.bukkit.mobmanager.common.util.LocationCache;
import org.bukkit.Location;
import org.bukkit.entity.LivingEntity;

public class ExploitsPlayerData
{	
	private ExtendedEntityType lastMob = null;
	private int sameMobKillCount = 0;
	
	private int spawnedMobKillCount = 0;
	
	private long lastKill = 0;
	
	private Location loc = null;
	private int killCount = 0;
	
	public long getLastKillTime()
	{
		long lastKill = this.lastKill;
		this.lastKill = System.currentTimeMillis();
		return lastKill;
	}
	
	public int getNewKillCount(ExtendedEntityType type)
	{		
		if (lastMob == type)
		{
			return ++sameMobKillCount;
		}
		
		lastMob = type;
		return sameMobKillCount = 0;
	}
	
	public int getNewNearbyKillCount(LivingEntity entity, int rangeSquared)
	{
		Location cacheLoc = entity.getLocation(LocationCache.getCachedLocation());
		
		if (loc == null)
		{
			loc = new Location(cacheLoc.getWorld(), 0.0, 5000.0, 0.0);
		}
		
		// If the location is out of range we reset count to 1
		if (entity.getLocation(cacheLoc).distanceSquared(loc) > rangeSquared)
		{
			killCount = 1;
		}
		else
		{
			++killCount;
		}
		
		// Copy the new location
		loc.setWorld(cacheLoc.getWorld());
		loc.setX(cacheLoc.getX());
		loc.setY(cacheLoc.getY());
		loc.setZ(cacheLoc.getZ());
		
		return killCount;
	}

	public int getSpawnedMobKillCount(LivingEntity entity)
	{
		if (BountySpawnListener.spawnerMob(entity))
		{
			return ++spawnedMobKillCount;
		}
		
		return spawnedMobKillCount = 0;
	}
}
